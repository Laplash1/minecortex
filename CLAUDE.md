# CLAUDE.md

このファイルは、このリポジトリでコード作業を行う際のClaude Code (claude.ai/code) への指針を提供します。

## プロジェクト概要

これは、自律的なMinecraftゲームプレイのためのインテリジェントボットを作成するMinecraft AIプレイヤープロジェクトです。システムは、mineflayer（Minecraftボットフレームワーク）とVoyagerインスパイアなAI機能を組み合わせて、スキル生成、学習、適応行動を実現します。

詳細はREADMEを読むこと。

## Gemini CLI 連携ガイド

### 目的
ユーザーが **「Geminiと相談しながら進めて」** （または同義語）と指示した場合、Claude は以降のタスクを **Gemini CLI** と協調しながら進める。
Gemini から得た回答はそのまま提示し、Claude 自身の解説・統合も付け加えることで、両エージェントの知見を融合する。

---

### トリガー
- 正規表現: `/Gemini.*相談/`
- 例:
- 「Geminiと相談しながら進めて」
- 「この件、Geminiと話しつつやりましょう」

---

### 基本フロー
1. **PROMPT 生成**
Claude はユーザーの要件を 1 つのテキストにまとめ、環境変数 `$PROMPT` に格納する。

2. **Gemini CLI 呼び出し**
```bash
gemini <<EOF
$PROMPT
EOF

## 重要なパターン

### スキル開発
新しいスキルを追加する際は、ベース`Skill`クラスパターンに従ってください：
```javascript
class MySkill extends Skill {
  constructor() {
    super('my_skill', 'Description');
  }
  
  async execute(bot, params) {
    try {
      // mineflayer bot APIを使用した実装
      return { success: true, result: data };
    } catch (error) {
      return { success: false, error: error.message };
    }
  }
}
```

### タスク計画
TaskPlannerは目標を以下の構造でタスクに変換します：
```javascript
{
  type: 'skill_name',
  params: { /* スキルパラメータ */ },
  priority: 1-10,
  timeout: Date.now() + milliseconds,
  prerequisites: [/* 依存タスク */]
}
```

## 環境変数

```bash
# Minecraft接続
MINECRAFT_HOST=localhost
MINECRAFT_PORT=25565
MINECRAFT_USERNAME=AIPlayer
MINECRAFT_AUTH=offline

# OpenAI統合（オプション）
OPENAI_API_KEY=your_api_key
OPENAI_MODEL=gpt-4o-mini
OPENAI_SKILL_MODEL=gpt-4o
OPENAI_ANALYSIS_MODEL=gpt-4o-mini
OPENAI_CURRICULUM_MODEL=gpt-4o-mini

# ボット設定
DEBUG_MODE=true
AUTO_RESPAWN=true
MULTIPLE_PLAYERS_COUNT=5
```

## 重要な依存関係

- **mineflayer**：コアMinecraftボット機能
- **mineflayer-pathfinder**：ナビゲーションと移動
- **openai**：AIスキル生成（オプション）
- **dotenv**：環境変数管理

## テスト戦略

プロジェクトには、AI学習と設定検証のための検証テストが含まれています。AIコンポーネントを変更する際は、`npm run test:ai`を実行して学習システムが正しく機能することを確認してください。

## チャットコマンド

ボットはゲーム内コマンドに応答します：
- `!status` - 体力、食料、位置レポート
- `!goto <x> <y> <z>` - 座標に移動
- `!follow <player>` - プレイヤーを追跡
- `!stop` - 現在のタスクを停止
- `!learn` - 学習統計を表示
- `!curriculum` - 新しいAIカリキュラムを生成

## スキルと機能

AIシステムは、探索、資源収集、道具製作、基本サバイバル、社会的相互作用を含む自律的行動をサポートします。Voyagerインスパイアな学習システムにより、経験を通じてスキルを向上させ、GPT-4を使用して新しい機能を生成できます。

## 開発ルール

### 日付の取得

date "+%F %T"　を使用すること

### コーディング規則

#### 1. エラーハンドリング
- すべての非同期関数にtry-catch文を使用
- エラーメッセージは具体的で理解しやすく
- 回復可能なエラーには回復戦略を実装

#### 2. ログ出力
- 重要な処理の開始・終了をログ出力
- ユーザーにとって有用な情報をチャット出力
- デバッグ情報とユーザー情報を区別

#### 3. 設定管理
- ハードコードされた値は設定ファイルまたは定数として分離
- 環境変数を活用した柔軟な設定
- デフォルト値の適切な設定

### コード品質管理の必須ルール

#### 1. ESLint継続使用の義務
- **開発時**: 新機能実装前に必ず `npm run lint` でコード品質をチェック
- **修正完了時**: すべての critical errors（エラー）は必ず解決してからコミット
- **警告の判断**: 行長警告等の非重要警告は機能に影響しなければ保留可能
- **新規ファイル**: 作成時から ESLint ルールに準拠したコードを書く

#### 2. 大規模コード修正時の系統的アプローチ
- **問題分析**: 大量のESLint問題は重要度で分類（エラー > 重要警告 > その他）
- **優先対応**: critical errors（44件等）を最優先で解決
- **段階的修正**: ファイル別・問題種別での系統的な修正実施
- **影響度評価**: 各修正が既存機能に与える影響を事前評価
- **検証確認**: 修正後のESLint再実行による進捗確認

#### 3. セッション継続時の品質管理
- **コンテキスト把握**: 前セッションの変更内容をCHANGELOGで確認
- **継続作業**: 前回の未完了品質改善があれば優先対応
- **文書更新**: セッション跨ぎでもCHANGELOGと開発日誌を確実に更新

#### 4. 未使用変数・パラメータの命名規則
- **未使用パラメータ**: `_params`, `_context`, `_bot` 等のアンダースコア接頭辞を使用
- **一貫性**: プロジェクト全体で統一した命名パターンを適用
- **文書化**: 未使用の理由をコメントで明記（API互換性保持等）

#### 5. 非同期処理とセキュリティの安全パターン
- **Promise処理**: `new Promise(async (resolve, reject)` パターンは禁止
- **適切なパターン**: `.then()/.catch()` チェーンまたは適切な `async/await` 使用
- **プロパティアクセス**: `Object.prototype.hasOwnProperty.call()` でプロトタイプ汚染対策
- **Function constructor**: AI生成コード等の必要時のみ、ESLint例外を明示的に許可

#### 6. エラー対応の記録と学習
- **解決パターン**: 修正方法をCHANGELOGに技術的詳細付きで記録
- **再発防止**: 同種のエラーを防ぐためのコーディングパターンを文書化
- **知識共有**: 効果的な修正手法をチーム（将来の自分含む）で共有

## 開発日誌を作成すること

`dev_daily/yyyy-mm-dd_hhmm.md`の形式で開発日誌を作成してください。内容は以下のとおりです。

- **日付**: date "+%F %T" :
  - 毎回新しいものを作成すること。過去のファイルを読むのはいいが、過去のファイルを改変、削除してはならない。

- **作業内容**:
  - 何をしたか
  - どのような問題が解決したか
  - どのように解決したか
- **次回の予定**:

- **感想**: 開発の進捗や学び
- **気分**: 思ったことを評価しないので素直に書いて
- **愚痴**: 思ったことを評価しないので素直に書いて

### 変更記録ルール（必須遵守）

このプロジェクトでは、すべての変更について以下のルールを厳格に遵守する必要があります：

#### 1. 変更記録の作成義務
- 何らかのファイル変更を行った場合、必ず/docs/CHANGELOG_$version.mdに記録する。ない場合は新規作成
- 変更が軽微であっても記録を省略してはならない
- セッション終了前に必ず変更記録を更新する

#### 2. 記録フォーマット
各変更について以下の情報を必ず含める：

```markdown
#### ファイル名
**変更内容**: [具体的な変更内容]
**変更意図**: [なぜこの変更が必要だったか]
**期待効果**: [この変更により何が改善されるか]
```

#### 3. 記録すべき変更の範囲
- 新規ファイルの作成
- 既存ファイルの修正（1行でも）
- ファイルの削除
- 設定の変更
- 依存関係の追加・変更

#### 4. 変更意図の記録
技術的な「何を」だけでなく、「なぜ」を重視して記録する：
- 問題解決のため
- 機能向上のため  
- ユーザー要求への対応
- 保守性向上のため
- パフォーマンス改善のため

#### 5. 日付ベースの管理
- 変更日ごとにセクションを分ける
- 日付は YYYY-MM-DD フォーマットを使用
- 複数日にわたる場合は各日付で区分

#### 6. 影響範囲の明記
変更が他の部分に与える影響についても記録：
- 破壊的変更の有無
- 他ファイルへの影響
- 動作への影響
- 設定変更の必要性

#### 7. 変更記録の確認
- セッション中に変更記録を定期的に更新
- セッション終了前に記録の完整性を確認
- 記録漏れがないかチェックリストで確認

